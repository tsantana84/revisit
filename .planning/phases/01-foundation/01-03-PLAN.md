---
phase: 01-foundation
plan: 03
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - src/lib/supabase/client.ts
  - src/lib/supabase/server.ts
  - src/lib/supabase/middleware.ts
  - src/middleware.ts
  - .env.local.example
  - package.json
  - tsconfig.json
autonomous: true
requirements:
  - AUTH-05
must_haves:
  truths:
    - "Middleware extracts slug from URL and resolves it to restaurant_id"
    - "Resolved restaurant_id is available to server components via request headers"
    - "Invalid slugs result in a not-found page"
    - "Slug-to-restaurant_id mapping is cached in-memory across requests within same Edge instance"
    - "Supabase auth token is refreshed on every request via middleware"
  artifacts:
    - path: "src/middleware.ts"
      provides: "Next.js middleware entry point with tenant resolution"
      contains: "middleware"
    - path: "src/lib/supabase/middleware.ts"
      provides: "updateSession + tenant resolution logic"
      contains: "updateSession"
    - path: "src/lib/supabase/client.ts"
      provides: "Browser Supabase client factory"
      contains: "createBrowserClient"
    - path: "src/lib/supabase/server.ts"
      provides: "Server-side Supabase client factory"
      contains: "createServerClient"
  key_links:
    - from: "src/middleware.ts"
      to: "src/lib/supabase/middleware.ts"
      via: "Middleware entry delegates to updateSession"
      pattern: "import.*updateSession"
    - from: "src/lib/supabase/middleware.ts"
      to: "public.restaurants"
      via: "Service role client queries restaurants table by slug"
      pattern: "\\.from\\('restaurants'\\)"
---

<objective>
Create the Next.js middleware that resolves tenant slugs from URLs to restaurant_id values and the Supabase client factories for browser and server usage.

Purpose: Every tenant route needs restaurant_id to scope data queries. The middleware resolves this once per request and injects it as a header, avoiding per-component database lookups. The Supabase client factories standardize how the app interacts with Supabase across browser, server, and middleware contexts.
Output: Middleware with slug caching, three Supabase client factories, and env var template.
</objective>

<execution_context>
@/Users/thiagosantana/.claude/get-shit-done/workflows/execute-plan.md
@/Users/thiagosantana/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Set up Next.js project and Supabase client factories</name>
  <files>package.json, tsconfig.json, src/lib/supabase/client.ts, src/lib/supabase/server.ts, .env.local.example</files>
  <action>
**Initialize Next.js project** (if not already initialized):
```bash
npx create-next-app@latest . --typescript --tailwind --eslint --app --src-dir --import-alias "@/*" --no-git
```
If package.json already exists from Plan 01-02, install Next.js and dependencies instead:
```bash
npm install next react react-dom @supabase/ssr @supabase/supabase-js
npm install -D @types/react @types/react-dom typescript
```

Install `@supabase/ssr` (not the deprecated `@supabase/auth-helpers-nextjs`):
```bash
npm install @supabase/ssr
```

**File: `.env.local.example`** (template, NOT actual secrets):
```
NEXT_PUBLIC_SUPABASE_URL=http://127.0.0.1:54321
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key-here
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key-here
```

Note: Use ANON_KEY naming (not PUBLISHABLE_KEY) — the local Supabase CLI outputs `anon key`. If the production Supabase project uses the new naming scheme, rename at that point.

**File: `src/lib/supabase/client.ts`** — Browser client factory:
```typescript
import { createBrowserClient } from '@supabase/ssr'

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}
```

**File: `src/lib/supabase/server.ts`** — Server client factory (for Server Components and Route Handlers):
```typescript
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'

export async function createClient() {
  const cookieStore = await cookies()
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() { return cookieStore.getAll() },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {
            // setAll can fail in Server Components (read-only cookies)
            // This is expected — middleware handles the write
          }
        },
      },
    }
  )
}
```

Use `getAll`/`setAll` ONLY — never the old `get`/`set`/`remove` methods (deprecated in @supabase/ssr).
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`. Both client factories export a `createClient` function.</verify>
  <done>Next.js project initialized with @supabase/ssr. Browser and server client factories exist at src/lib/supabase/client.ts and server.ts. Env var template exists.</done>
</task>

<task type="auto">
  <name>Task 2: Create Next.js middleware with tenant slug resolution and caching</name>
  <files>src/middleware.ts, src/lib/supabase/middleware.ts</files>
  <action>
**File: `src/lib/supabase/middleware.ts`**

Create the `updateSession` function that handles both auth token refresh AND tenant slug resolution.

1. **Module-level slug cache:** `const slugCache = new Map<string, { restaurantId: string; name: string; cachedAt: number }>()`. Add a TTL of 5 minutes (300000ms). On cache hit, check if `Date.now() - cachedAt > 300000` — if stale, delete and re-query. This is acceptable for Edge Runtime (no `unstable_cache` available).

2. **Auth token refresh:** Create a Supabase server client with the request/response cookie contract (getAll from request, setAll to both request and response). Call `supabase.auth.getUser()` (NOT `getSession()` — getSession does not verify JWT signature server-side).

3. **Tenant slug resolution:** Extract the first path segment as slug. Determine if this is a tenant route using a helper function `isTenantRoute(pathname)` — returns true if pathname matches `/{slug}/...` but NOT `/dashboard`, `/login`, `/api`, `/_next`, `/not-found`, or static file extensions.

4. For tenant routes: Check slugCache first. On miss, create a service-role Supabase client (using `SUPABASE_SERVICE_ROLE_KEY`, NOT `NEXT_PUBLIC_`) and query `restaurants` table: `.select('id, name').eq('slug', slug).is('deleted_at', null).single()`.

5. If restaurant not found: return `NextResponse.rewrite(new URL('/not-found', request.url))`.

6. If found: Set `x-restaurant-id` and `x-restaurant-name` headers on the response. Cache the result.

7. Return the response with refreshed cookies + tenant headers.

**File: `src/middleware.ts`**

Thin entry point:
```typescript
import { type NextRequest } from 'next/server'
import { updateSession } from '@/lib/supabase/middleware'

export async function middleware(request: NextRequest) {
  return await updateSession(request)
}

export const config = {
  matcher: [
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
  ],
}
```

IMPORTANT: The service role key must NEVER be prefixed with `NEXT_PUBLIC_` — it runs only in middleware (server-side). Including it in the client bundle would allow any user to bypass RLS.
  </action>
  <verify>
1. `npx tsc --noEmit` passes.
2. Start the dev server: `npm run dev`. Navigate to `http://localhost:3000/demo-restaurant` (the seeded slug) — check browser DevTools Network tab for `x-restaurant-id` header on the response. Navigate to `http://localhost:3000/invalid-slug-xyz` — should render the not-found page.
3. Second request to `/demo-restaurant` should be faster (cache hit — verify with a console.log in the cache check path during development).
  </verify>
  <done>Middleware resolves slug to restaurant_id on tenant routes, caches results in-memory with 5-minute TTL, injects x-restaurant-id and x-restaurant-name headers, returns 404 for invalid slugs, and refreshes Supabase auth tokens on every request. Service role key is server-only.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` compiles all TypeScript without errors
2. `npm run dev` starts without errors
3. Navigating to /demo-restaurant sets x-restaurant-id header
4. Navigating to /invalid-slug shows not-found page
5. Supabase client factories work in both browser and server contexts
6. Service role key not exposed in client bundle (check .env.local.example has no NEXT_PUBLIC_ prefix on service role key)
</verification>

<success_criteria>
- Middleware resolves slug → restaurant_id without per-component DB queries
- Slug cache avoids repeated DB queries within 5-minute window
- Invalid slugs produce a not-found response
- Auth tokens are refreshed on every middleware pass
- Three Supabase client factories exist (browser, server, middleware)
- Service role key is never exposed to the client
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
