---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - supabase/migrations/0004_hooks.sql
  - supabase/tests/rls_isolation.test.ts
  - vitest.config.ts
  - package.json
autonomous: true
requirements:
  - AUTH-05
user_setup:
  - service: supabase-local
    why: "Local Supabase instance for tests"
    env_vars:
      - name: SUPABASE_URL
        source: "Output of `supabase start` — defaults to http://127.0.0.1:54321"
      - name: SUPABASE_ANON_KEY
        source: "Output of `supabase start` — printed as anon key"
      - name: SUPABASE_SERVICE_ROLE_KEY
        source: "Output of `supabase start` — printed as service_role key"
must_haves:
  truths:
    - "JWT issued after login contains restaurant_id and app_role claims"
    - "A query authenticated as Restaurant A returns zero rows from Restaurant B"
    - "An unauthenticated query returns zero rows from all tenant tables"
    - "Cross-tenant test suite passes using Supabase client SDK"
  artifacts:
    - path: "supabase/migrations/0004_hooks.sql"
      provides: "Custom access token hook injecting restaurant_id + app_role into JWT"
      contains: "custom_access_token_hook"
    - path: "supabase/tests/rls_isolation.test.ts"
      provides: "SDK-based cross-tenant isolation tests"
      contains: "signInWithPassword"
    - path: "vitest.config.ts"
      provides: "Vitest configuration for integration tests"
      contains: "defineConfig"
  key_links:
    - from: "supabase/migrations/0004_hooks.sql"
      to: "public.restaurant_staff"
      via: "Hook queries restaurant_staff to get restaurant_id + role"
      pattern: "FROM public\\.restaurant_staff"
    - from: "supabase/tests/rls_isolation.test.ts"
      to: "supabase/migrations/0004_hooks.sql"
      via: "Tests verify JWT claims injected by hook"
      pattern: "restaurant_id"
---

<objective>
Create the Supabase Custom Access Token Hook that injects tenant identity into every JWT, and build the SDK-based cross-tenant isolation test suite that verifies RLS works end-to-end.

Purpose: The hook is the mechanism that makes RLS work — without it, `get_restaurant_id()` returns null and all policies deny access. The test suite is the locked user decision that proves isolation on every deploy.
Output: Hook migration, Vitest integration test suite, and test configuration.
</objective>

<execution_context>
@/Users/thiagosantana/.claude/get-shit-done/workflows/execute-plan.md
@/Users/thiagosantana/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Custom Access Token Hook migration</name>
  <files>supabase/migrations/0004_hooks.sql</files>
  <action>
Create `supabase/migrations/0004_hooks.sql` with the Custom Access Token Hook function.

The function:
1. Receives `event JSONB` parameter, returns `JSONB`.
2. Extracts `user_id` from `event->>'user_id'`.
3. Queries `public.restaurant_staff` for that user_id WHERE deleted_at IS NULL, LIMIT 1.
4. If found, injects `restaurant_id` (as TEXT) and `app_role` (as TEXT) into `event->'claims'` using `jsonb_set`.
5. Returns the modified event.

Use `LANGUAGE plpgsql`, mark as `STABLE`.

Grant permissions:
```sql
GRANT USAGE ON SCHEMA public TO supabase_auth_admin;
GRANT EXECUTE ON FUNCTION public.custom_access_token_hook TO supabase_auth_admin;
GRANT SELECT ON TABLE public.restaurant_staff TO supabase_auth_admin;
REVOKE EXECUTE ON FUNCTION public.custom_access_token_hook FROM PUBLIC, authenticated, anon;
```

CRITICAL: The GRANT on restaurant_staff is essential — without it, the hook silently returns null claims because supabase_auth_admin cannot read the lookup table (Pitfall 5 from research).

After creating the function, configure the hook in `supabase/config.toml` by adding under `[auth]`:
```toml
[auth.hook.custom_access_token]
enabled = true
uri = "pg-functions://postgres/public/custom_access_token_hook"
```

Verify the config.toml section name matches Supabase CLI expectations — check research for exact format.
  </action>
  <verify>Run `supabase db reset` — migration 0004 applies without errors. Check function exists: `SELECT proname FROM pg_proc WHERE proname = 'custom_access_token_hook';`. Verify grants: `SELECT has_function_privilege('supabase_auth_admin', 'public.custom_access_token_hook(jsonb)', 'execute');` returns true.</verify>
  <done>Hook function exists, has correct grants, and is configured in config.toml. supabase_auth_admin can SELECT from restaurant_staff and EXECUTE the hook.</done>
</task>

<task type="auto">
  <name>Task 2: Create SDK-based cross-tenant isolation test suite</name>
  <files>supabase/tests/rls_isolation.test.ts, vitest.config.ts, package.json</files>
  <action>
**Install dependencies:**
```bash
npm init -y  # if package.json doesn't exist
npm install @supabase/supabase-js
npm install -D vitest typescript @types/node
```

**File: `vitest.config.ts`**

Configure Vitest for integration tests:
```typescript
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    include: ['supabase/tests/**/*.test.ts'],
    testTimeout: 30000,  // SDK calls to local Supabase need time
    hookTimeout: 30000,
  },
})
```

**File: `supabase/tests/rls_isolation.test.ts`**

Write the cross-tenant isolation test suite using Supabase JS SDK (locked decision: must use SDK, not SQL Editor).

Test setup (beforeAll):
1. Create an admin client using SERVICE_ROLE_KEY (bypasses RLS for setup only).
2. Use admin client to create two restaurants: "Restaurant A" (slug: 'test-a') and "Restaurant B" (slug: 'test-b'). Store their IDs.
3. Create 2 ranks per restaurant using admin client.
4. Create 3 test customers for Restaurant A and 2 for Restaurant B using admin client.
5. Use `supabase.auth.admin.createUser()` to create two auth users: ownerA@test.com and ownerB@test.com (with `email_confirm: true` to skip verification).
6. Insert restaurant_staff records linking ownerA to Restaurant A (role: 'owner') and ownerB to Restaurant B (role: 'owner').

Environment variables (read from process.env with defaults for local dev):
- SUPABASE_URL defaults to 'http://127.0.0.1:54321'
- SUPABASE_SERVICE_ROLE_KEY — required (from `supabase start` output)
- SUPABASE_ANON_KEY — required (from `supabase start` output)

Test cases:
1. **"Restaurant A owner sees only Restaurant A customers"** — Sign in as ownerA, query customers, assert all returned rows have restaurant_id === restaurantAId, assert count >= 3.

2. **"Restaurant B owner sees only Restaurant B customers"** — Sign in as ownerB, query customers, assert all returned rows have restaurant_id === restaurantBId, assert count >= 2.

3. **"Restaurant A owner cannot see Restaurant B ranks"** — Sign in as ownerA, query ranks, assert none have restaurantBId.

4. **"Unauthenticated client gets zero rows"** — Create anon client (ANON_KEY, no sign-in), query customers, assert data has length 0.

5. **"Restaurant A owner cannot insert into Restaurant B"** — Sign in as ownerA, attempt to insert a customer with restaurant_id = restaurantBId, assert error (RLS policy violation).

6. **"JWT contains restaurant_id and app_role claims"** — Sign in as ownerA, get session, decode the access_token JWT (use base64 decode, no library needed for reading claims), assert `restaurant_id` equals restaurantAId and `app_role` equals 'owner'.

Test cleanup (afterAll):
- Use admin client to delete test data in reverse order: sales, reward_redemptions, point_transactions, customers, ranks, reward_configs, restaurant_staff, restaurants.
- Use admin client to delete auth users: `supabase.auth.admin.deleteUser(userId)`.

Add npm script to package.json: `"test:rls": "vitest run supabase/tests/"`.

IMPORTANT: Each test case must create its OWN Supabase client with ANON_KEY and sign in — do NOT reuse clients across tests. The JWT is baked into the client after signIn.
  </action>
  <verify>
Run `supabase start` (if not running), then `npm run test:rls`. All 6 test cases must pass. The output should show:
- Restaurant A owner: sees 3+ customers, all with correct restaurant_id
- Restaurant B owner: sees 2+ customers, all with correct restaurant_id
- Anon: sees 0 customers
- Cross-tenant insert: rejected
- JWT claims: present and correct
  </verify>
  <done>All 6 cross-tenant isolation tests pass using the Supabase JS SDK against a local Supabase instance. Tests verify data isolation, unauthenticated access denial, cross-tenant write prevention, and JWT claim injection.</done>
</task>

</tasks>

<verification>
1. `supabase db reset` applies all migrations (0001-0004) without errors
2. Hook function is registered and configured in config.toml
3. `npm run test:rls` passes all 6 test cases
4. Tests use Supabase JS SDK client (not SQL queries or Studio) per locked decision
5. JWT decoded from session contains restaurant_id and app_role claims
</verification>

<success_criteria>
- Custom Access Token Hook injects restaurant_id + app_role into JWT on every login
- Cross-tenant test suite passes: Restaurant A cannot see Restaurant B data
- Unauthenticated access returns zero rows
- Cross-tenant writes are rejected by RLS
- Test suite uses SDK (not SQL Editor) per locked user decision
- Tests are repeatable — cleanup removes all test data
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
