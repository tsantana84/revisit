---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/0001_schema.sql
  - supabase/migrations/0002_rls.sql
  - supabase/migrations/0003_views.sql
  - supabase/seed.sql
  - supabase/config.toml
autonomous: true
requirements:
  - AUTH-05
must_haves:
  truths:
    - "Every table has a restaurant_id column for tenant isolation"
    - "RLS is enabled on every table with tenant isolation policies"
    - "Soft-deleted rows are filtered by views, not by RLS policies"
    - "A demo restaurant with sample data exists after seeding"
  artifacts:
    - path: "supabase/migrations/0001_schema.sql"
      provides: "All database tables with restaurant_id, deleted_at, proper types"
      contains: "CREATE TABLE"
    - path: "supabase/migrations/0002_rls.sql"
      provides: "RLS policies and helper functions for tenant isolation"
      contains: "CREATE POLICY"
    - path: "supabase/migrations/0003_views.sql"
      provides: "Active-record views filtering soft-deleted rows"
      contains: "CREATE VIEW"
    - path: "supabase/seed.sql"
      provides: "Demo restaurant with sample customers, ranks, rewards, transactions"
      contains: "INSERT INTO"
  key_links:
    - from: "supabase/migrations/0002_rls.sql"
      to: "supabase/migrations/0001_schema.sql"
      via: "RLS policies reference tables created in 0001"
      pattern: "ON public\\."
    - from: "supabase/migrations/0003_views.sql"
      to: "supabase/migrations/0001_schema.sql"
      via: "Views select from base tables"
      pattern: "FROM public\\."
---

<objective>
Create the complete PostgreSQL schema for REVISIT's multi-tenant loyalty platform, with RLS policies enforcing tenant isolation and soft-delete views for application queries.

Purpose: Every feature in Phases 2-5 depends on a correctly designed, tenant-isolated database. Getting this wrong means retrofitting RLS later, which is prohibitively expensive.
Output: Supabase migration files, RLS policies, soft-delete views, and a seed script with demo data.
</objective>

<execution_context>
@/Users/thiagosantana/.claude/get-shit-done/workflows/execute-plan.md
@/Users/thiagosantana/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database schema migration with all tables</name>
  <files>supabase/config.toml, supabase/migrations/0001_schema.sql</files>
  <action>
Initialize the Supabase project with `supabase init` (creates supabase/ directory and config.toml).

Create `supabase/migrations/0001_schema.sql` with the following tables. All IDs are UUID (using `gen_random_uuid()`). Points columns are INTEGER. Every table has `restaurant_id UUID NOT NULL`, `created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()`, and `deleted_at TIMESTAMPTZ` (soft delete per locked decision).

1. **`restaurants`** — id (PK), name TEXT NOT NULL, slug TEXT UNIQUE NOT NULL, created_at, deleted_at. Add index on slug.

2. **`restaurant_staff`** — id (PK), restaurant_id FK→restaurants, user_id UUID NOT NULL REFERENCES auth.users(id), role app_role NOT NULL ('owner' | 'manager' enum), created_at, deleted_at. UNIQUE(user_id) constraint (one restaurant per user for POC). Create the `app_role` ENUM type first: `CREATE TYPE public.app_role AS ENUM ('owner', 'manager');`

3. **`customers`** — id (PK), restaurant_id FK→restaurants, name TEXT NOT NULL, phone TEXT NOT NULL, card_number TEXT UNIQUE, points_balance INTEGER NOT NULL DEFAULT 0, visit_count INTEGER NOT NULL DEFAULT 0, current_rank_id UUID REFERENCES ranks(id), created_at, deleted_at. Add UNIQUE(restaurant_id, phone) for per-tenant phone uniqueness.

4. **`ranks`** — id (PK), restaurant_id FK→restaurants, name TEXT NOT NULL, min_points INTEGER NOT NULL, sort_order INTEGER NOT NULL, created_at, deleted_at. Add index on (restaurant_id, min_points).

5. **`reward_configs`** — id (PK), restaurant_id FK→restaurants, name TEXT NOT NULL, description TEXT, points_required INTEGER NOT NULL, is_active BOOLEAN NOT NULL DEFAULT TRUE, created_at, deleted_at.

6. **`point_transactions`** — id (PK), restaurant_id FK→restaurants, customer_id UUID NOT NULL FK→customers, points_delta INTEGER NOT NULL, balance_after INTEGER NOT NULL, transaction_type TEXT NOT NULL, reference_id UUID, note TEXT, created_at, deleted_at. Add index on (customer_id, created_at DESC) and (restaurant_id).

7. **`reward_redemptions`** — id (PK), restaurant_id FK→restaurants, customer_id UUID NOT NULL FK→customers, reward_config_id UUID NOT NULL FK→reward_configs, points_spent INTEGER NOT NULL, created_at, deleted_at.

8. **`sales`** — id (PK), restaurant_id FK→restaurants, customer_id UUID NOT NULL FK→customers, staff_id UUID NOT NULL FK→restaurant_staff, amount_cents INTEGER NOT NULL, points_earned INTEGER NOT NULL, created_at, deleted_at.

Order table creation to satisfy FK constraints: restaurants → ranks → restaurant_staff → customers → point_transactions, reward_configs → reward_redemptions, sales.

Enable RLS on every table at the bottom of this migration:
```sql
ALTER TABLE public.restaurants ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.restaurant_staff ENABLE ROW LEVEL SECURITY;
-- ... repeat for all tables
```

Do NOT put RLS policies in this file — those go in 0002.
  </action>
  <verify>Run `supabase start` then `supabase db reset` — migration applies without errors. Verify all tables exist with `\dt public.*` via `supabase db` or by checking the local Supabase Studio at http://127.0.0.1:54323.</verify>
  <done>All 8 tables exist with correct columns, types, constraints, and indexes. RLS is enabled on every table. The app_role enum type exists.</done>
</task>

<task type="auto">
  <name>Task 2: Create RLS policies, helper functions, soft-delete views, and seed data</name>
  <files>supabase/migrations/0002_rls.sql, supabase/migrations/0003_views.sql, supabase/seed.sql</files>
  <action>
**File: `supabase/migrations/0002_rls.sql`**

Create the RLS helper functions and policies:

1. Create `get_restaurant_id()` — SECURITY DEFINER, STABLE, returns UUID, extracts `(auth.jwt() ->> 'restaurant_id')::UUID`. Set `search_path = ''`.

2. Create `get_app_role()` — SECURITY DEFINER, STABLE, returns TEXT, extracts `auth.jwt() ->> 'app_role'`. Set `search_path = ''`.

3. For EVERY tenant table (customers, ranks, reward_configs, point_transactions, reward_redemptions, sales), create a single `FOR ALL` policy named `tenant_isolation_{table}`:
   - `TO authenticated`
   - `USING (restaurant_id = (SELECT public.get_restaurant_id()))`
   - `WITH CHECK (restaurant_id = (SELECT public.get_restaurant_id()))`
   - CRITICAL: Use `(SELECT public.get_restaurant_id())` wrapper for query plan caching — without it, the function is called per-row.

4. For `restaurants` table: owners/managers can see their own restaurant. Policy: `USING (id = (SELECT public.get_restaurant_id()))`.

5. For `restaurant_staff` table: staff can see other staff in their restaurant. Policy: `USING (restaurant_id = (SELECT public.get_restaurant_id()))`.

Do NOT include `deleted_at IS NULL` in any RLS policy — this causes UPDATE conflicts when soft-deleting (the row becomes invisible mid-UPDATE). Soft-delete filtering happens at the view layer.

**File: `supabase/migrations/0003_views.sql`**

Create active-record views that filter soft-deleted rows. One view per table:
- `active_restaurants` — SELECT * FROM restaurants WHERE deleted_at IS NULL
- `active_customers` — same pattern
- `active_ranks` — same pattern
- `active_reward_configs` — same pattern
- `active_point_transactions` — same pattern
- `active_reward_redemptions` — same pattern
- `active_sales` — same pattern
- `active_restaurant_staff` — same pattern

**File: `supabase/seed.sql`**

Create seed data with one demo restaurant (per locked decision):

1. Insert a restaurant: name='Demo Restaurant', slug='demo-restaurant'.
2. Insert 4 ranks: Bronze (0 pts, order 1), Prata (500 pts, order 2), Gold (1500 pts, order 3), VIP (3000 pts, order 4). Use the demo restaurant's ID.
3. Insert 2 reward configs: "Café Grátis" (100 pts), "Sobremesa Grátis" (250 pts).
4. Insert 5 sample customers with varying points_balance and visit_count values. Assign ranks based on their points. Use card numbers like #0001-X format.
5. Insert sample point_transactions for some customers.
6. Do NOT insert auth.users — those are created at runtime via Supabase Auth. The seed is for business data only.

Use explicit UUIDs (gen_random_uuid() calls or hardcoded UUIDs with DO blocks) so that FK references work within the seed file.
  </action>
  <verify>Run `supabase db reset` — all 3 migrations apply and seed runs without errors. Check that views exist with `\dv public.*`. Verify seed data with `SELECT count(*) FROM public.restaurants;` (should be 1) and `SELECT count(*) FROM public.customers;` (should be 5).</verify>
  <done>RLS policies exist on all tables using the get_restaurant_id() helper with (SELECT ...) caching. No policy references deleted_at. All 8 active_* views exist. Demo restaurant with 5 customers, 4 ranks, and 2 rewards is seeded.</done>
</task>

</tasks>

<verification>
1. `supabase db reset` runs cleanly — all migrations + seed succeed
2. Every table shows `RLS enabled` in Supabase Studio or via `SELECT relname, relrowsecurity FROM pg_class WHERE relnamespace = 'public'::regnamespace AND relkind = 'r';`
3. Views filter soft-deleted rows: insert a customer, set deleted_at = NOW(), query active_customers — row should not appear
4. Seed data is queryable: demo restaurant, customers, ranks, rewards all present
</verification>

<success_criteria>
- All 8 tables created with correct schema, types, and constraints
- RLS enabled on every table with tenant isolation policies using get_restaurant_id()
- No RLS policy references deleted_at (view-based soft-delete pattern)
- Active-record views exist for all tables
- Demo restaurant with sample data seeded successfully
- `supabase db reset` runs end-to-end without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
