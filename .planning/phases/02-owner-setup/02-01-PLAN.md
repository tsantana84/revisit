---
phase: 02-owner-setup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/0005_branding.sql
  - supabase/migrations/0006_storage.sql
  - supabase/config.toml
  - src/lib/supabase/service.ts
  - src/lib/supabase/middleware.ts
  - src/lib/actions/auth.ts
  - src/app/(auth)/signup/page.tsx
  - src/app/(auth)/login/page.tsx
  - src/app/dashboard/owner/layout.tsx
  - src/app/dashboard/owner/page.tsx
  - src/app/dashboard/manager/layout.tsx
  - src/app/dashboard/manager/page.tsx
  - package.json
autonomous: true
requirements:
  - AUTH-01
  - AUTH-02
  - WL-03

must_haves:
  truths:
    - "Owner can sign up with email, password, and restaurant name — and is redirected to login with a success message"
    - "Owner can log in and land on /dashboard/owner"
    - "Manager can log in and land on /dashboard/manager"
    - "Unauthenticated users hitting /dashboard/** are redirected to /login"
    - "An owner cannot access /dashboard/manager and a manager cannot access /dashboard/owner"
    - "restaurants table has branding and config columns (primary_color, secondary_color, logo_url, program_name, earn_rate, reward_type, point_expiry_days)"
    - "ranks table has multiplier and min_visits columns"
    - "restaurant-logos storage bucket exists with INSERT/DELETE RLS policies"
  artifacts:
    - path: "supabase/migrations/0005_branding.sql"
      provides: "Branding and config columns on restaurants + multiplier/min_visits on ranks"
      contains: "ALTER TABLE public.restaurants"
    - path: "supabase/migrations/0006_storage.sql"
      provides: "restaurant-logos storage bucket with RLS"
      contains: "restaurant-logos"
    - path: "src/lib/supabase/service.ts"
      provides: "Service role client factory"
      exports: ["createServiceClient"]
    - path: "src/lib/actions/auth.ts"
      provides: "signup, login, logout Server Actions"
      exports: ["signup", "login", "logout"]
    - path: "src/app/(auth)/signup/page.tsx"
      provides: "Owner signup form page"
    - path: "src/app/(auth)/login/page.tsx"
      provides: "Login form page (shared by owners and managers)"
    - path: "src/app/dashboard/owner/layout.tsx"
      provides: "Owner dashboard layout with role guard"
    - path: "src/app/dashboard/manager/layout.tsx"
      provides: "Manager dashboard layout with role guard"
  key_links:
    - from: "src/app/(auth)/signup/page.tsx"
      to: "src/lib/actions/auth.ts#signup"
      via: "useActionState + form action"
      pattern: "useActionState\\(signup"
    - from: "src/lib/actions/auth.ts#signup"
      to: "supabase.auth.signUp"
      via: "Supabase Auth SDK"
      pattern: "auth\\.signUp"
    - from: "src/lib/actions/auth.ts#signup"
      to: "src/lib/supabase/service.ts"
      via: "Service role client for restaurant + staff insert"
      pattern: "createServiceClient"
    - from: "src/lib/actions/auth.ts#login"
      to: "src/app/dashboard/owner/page.tsx"
      via: "redirect based on JWT app_role claim"
      pattern: "redirect.*dashboard/owner"
    - from: "src/lib/supabase/middleware.ts"
      to: "/login"
      via: "Dashboard route protection redirect"
      pattern: "pathname\\.startsWith.*dashboard"
---

<objective>
Create the database schema migration for branding/config columns, the service role client factory, the complete owner signup and login auth flows, and the role-protected dashboard route structure.

Purpose: This is the foundational plan for Phase 2 — every other plan depends on the schema columns, the service client, the auth flow, and the dashboard routes this plan creates.

Output: Working signup -> login -> dashboard flow with role-based routing. Schema ready for branding and program config forms in subsequent plans.
</objective>

<execution_context>
@/Users/thiagosantana/.claude/get-shit-done/workflows/execute-plan.md
@/Users/thiagosantana/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-owner-setup/02-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@.planning/phases/01-foundation/01-03-SUMMARY.md
@src/lib/supabase/middleware.ts
@src/lib/supabase/server.ts
@src/lib/supabase/client.ts
@supabase/migrations/0001_schema.sql
@supabase/config.toml
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schema migration for branding/config columns and storage bucket</name>
  <files>
    supabase/migrations/0005_branding.sql
    supabase/migrations/0006_storage.sql
    supabase/config.toml
    package.json
  </files>
  <action>
    **0005_branding.sql** — Add columns to restaurants and ranks:

    ```sql
    ALTER TABLE public.restaurants
      ADD COLUMN IF NOT EXISTS program_name      TEXT,
      ADD COLUMN IF NOT EXISTS primary_color     TEXT NOT NULL DEFAULT '#000000',
      ADD COLUMN IF NOT EXISTS secondary_color   TEXT NOT NULL DEFAULT '#FFFFFF',
      ADD COLUMN IF NOT EXISTS logo_url          TEXT,
      ADD COLUMN IF NOT EXISTS earn_rate         INTEGER NOT NULL DEFAULT 2,
      ADD COLUMN IF NOT EXISTS reward_type       TEXT NOT NULL DEFAULT 'cashback'
        CHECK (reward_type IN ('cashback', 'free_product', 'progressive_discount')),
      ADD COLUMN IF NOT EXISTS point_expiry_days INTEGER;

    ALTER TABLE public.ranks
      ADD COLUMN IF NOT EXISTS multiplier  NUMERIC(4,2) NOT NULL DEFAULT 1.0,
      ADD COLUMN IF NOT EXISTS min_visits  INTEGER NOT NULL DEFAULT 0;
    ```

    **0006_storage.sql** — Create restaurant-logos public bucket with RLS for INSERT/DELETE:

    ```sql
    INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
    VALUES (
      'restaurant-logos', 'restaurant-logos', true, 1048576,
      ARRAY['image/jpeg', 'image/png', 'image/webp', 'image/svg+xml']
    ) ON CONFLICT (id) DO NOTHING;
    ```

    Add INSERT policy (`owner_upload_logo`) and DELETE policy (`owner_delete_logo`) on `storage.objects` scoped to `bucket_id = 'restaurant-logos'` AND `(string_to_array(name, '/'))[1] = (SELECT public.get_restaurant_id())::TEXT` AND `(SELECT public.get_app_role()) = 'owner'`. Use `string_to_array` instead of `storage.foldername()` for local CLI compatibility (see research Open Question 3).

    **config.toml** — Ensure `[auth.email]` section has `enable_confirmations = false` for local dev (prevents Pitfall 6 from research).

    **package.json** — Run `npm install zod slugify` and `npm install -D @types/slugify`. These are needed by the auth actions in Task 2.
  </action>
  <verify>
    Run `npx supabase db reset` — must complete without errors. Then verify:
    - `SELECT column_name FROM information_schema.columns WHERE table_name = 'restaurants' AND column_name IN ('program_name', 'primary_color', 'earn_rate', 'reward_type')` returns 4 rows
    - `SELECT column_name FROM information_schema.columns WHERE table_name = 'ranks' AND column_name IN ('multiplier', 'min_visits')` returns 2 rows
    - `SELECT id FROM storage.buckets WHERE id = 'restaurant-logos'` returns 1 row
    - `npm ls zod slugify` exits 0
  </verify>
  <done>
    restaurants table has program_name, primary_color, secondary_color, logo_url, earn_rate, reward_type, point_expiry_days columns. ranks table has multiplier and min_visits columns. restaurant-logos bucket exists with INSERT/DELETE RLS policies. zod and slugify installed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Service role client, auth Server Actions, auth pages, and middleware dashboard protection</name>
  <files>
    src/lib/supabase/service.ts
    src/lib/supabase/middleware.ts
    src/lib/actions/auth.ts
    src/app/(auth)/signup/page.tsx
    src/app/(auth)/login/page.tsx
    src/app/(auth)/layout.tsx
    src/app/dashboard/owner/layout.tsx
    src/app/dashboard/owner/page.tsx
    src/app/dashboard/manager/layout.tsx
    src/app/dashboard/manager/page.tsx
  </files>
  <action>
    **src/lib/supabase/service.ts** — Create service role client factory. Single function `createServiceClient()` that returns `createClient(URL, SERVICE_ROLE_KEY, { auth: { persistSession: false, autoRefreshToken: false, detectSessionInUrl: false } })`. Import `createClient` from `@supabase/supabase-js` (NOT `@supabase/ssr`). This file must NEVER be imported in client components.

    **src/lib/actions/auth.ts** — Three Server Actions:

    1. `signup(prevState, formData)`:
       - Validate with Zod: `restaurantName` (min 2), `email` (valid email), `password` (min 8)
       - `supabase.auth.signUp({ email, password })` using the anon/cookie client from `@/lib/supabase/server`
       - On success, use `createServiceClient()` to insert into `restaurants` (name, slug via `slugify(name, { lower: true, strict: true })`, program_name = name) and `restaurant_staff` (restaurant_id, user_id, role: 'owner')
       - **Critical atomicity**: If restaurant insert fails, call `serviceClient.auth.admin.deleteUser(userId)` to clean up. If staff insert fails, delete restaurant AND auth user.
       - Handle slug collision: catch Postgres error code `23505` on restaurants insert — append random 4-char suffix and retry once, or return user-friendly error.
       - After all inserts succeed: call `supabase.auth.signOut()` then `redirect('/login?signup=success')`. The signOut forces a fresh login which triggers the JWT hook with the now-populated restaurant_staff row (see research Pitfall 1). Do NOT wrap `redirect()` in try/catch — Next.js throws a special NEXT_REDIRECT error.

    2. `login(prevState, formData)`:
       - Validate email and password with Zod
       - `supabase.auth.signInWithPassword({ email, password })`
       - On success, call `supabase.auth.getUser()` to get the user. Then call `supabase.auth.getSession()` to get the access_token. Decode the JWT with `jwtDecode` to read `app_role`.
       - If `app_role === 'owner'` → `redirect('/dashboard/owner')`
       - If `app_role === 'manager'` → `redirect('/dashboard/manager')`
       - If no role → `supabase.auth.signOut()` + return error "Conta nao associada a nenhum restaurante"
       - Install `jwt-decode` if not already in package.json: `npm install jwt-decode`

    3. `logout()`:
       - `supabase.auth.signOut()` then `redirect('/login')`

    **src/app/(auth)/layout.tsx** — Minimal layout for auth pages (no dashboard chrome). Render `{children}` with simple centered container.

    **src/app/(auth)/signup/page.tsx** — Client component using `useActionState(signup, undefined)`. Form with fields: restaurantName, email, password. Show per-field validation errors from Zod and a general message area. Show success banner if URL has `?signup=success` (use `useSearchParams`). Disabled submit button when pending. All text in pt-BR.

    **src/app/(auth)/login/page.tsx** — Client component using `useActionState(login, undefined)`. Form with email and password. Show `?signup=success` banner ("Conta criada com sucesso! Faca login para continuar."). Link to /signup. All text in pt-BR.

    **src/lib/supabase/middleware.ts** — Extend the existing `updateSession()` function to protect dashboard routes. After the existing `await supabase.auth.getUser()` call and BEFORE the tenant slug resolution:

    - Import `jwtDecode` from `jwt-decode`
    - Check if pathname starts with `/dashboard`
    - If yes, get session via `supabase.auth.getSession()`, decode access_token to read `app_role`
    - If no session → redirect to `/login`
    - If `/dashboard/owner` and role !== 'owner' → redirect to `/login`
    - If `/dashboard/manager` and role !== 'manager' → redirect to `/login`
    - If `/dashboard` (bare, no sub-path) and role is 'owner' → redirect to `/dashboard/owner`; if 'manager' → redirect to `/dashboard/manager`
    - Also add `/signup` to the `NON_TENANT_PREFIXES` array in `isTenantRoute()` so signup page is not treated as a tenant slug

    **src/app/dashboard/owner/layout.tsx** — Server Component. Calls `supabase.auth.getUser()`. If not authenticated, redirect to `/login`. Then call `supabase.auth.getSession()` and decode JWT to verify `app_role === 'owner'`. If not owner, redirect to `/login`. This is a defense-in-depth check (middleware does fast redirect, layout does authoritative check). Render children with basic dashboard shell (header with restaurant name placeholder, logout button calling the logout action).

    **src/app/dashboard/owner/page.tsx** — Simple placeholder Server Component: "Painel do Proprietario" heading. This page will be enriched in later phases.

    **src/app/dashboard/manager/layout.tsx** — Same pattern as owner layout but checks `app_role === 'manager'`. Minimal shell with logout.

    **src/app/dashboard/manager/page.tsx** — Placeholder: "Painel do Gerente" heading.
  </action>
  <verify>
    - `npx tsc --noEmit` passes with zero errors
    - Verify file existence: `ls src/lib/supabase/service.ts src/lib/actions/auth.ts src/app/\(auth\)/signup/page.tsx src/app/\(auth\)/login/page.tsx src/app/dashboard/owner/layout.tsx src/app/dashboard/owner/page.tsx src/app/dashboard/manager/layout.tsx src/app/dashboard/manager/page.tsx`
    - Grep for `createServiceClient` in `src/lib/actions/auth.ts` — must be imported from `@/lib/supabase/service`
    - Grep for `auth.signUp` in `src/lib/actions/auth.ts` — must exist
    - Grep for `auth.signOut` in `src/lib/actions/auth.ts` — must exist (signup atomicity pattern)
    - Grep for `redirect('/login?signup=success')` in `src/lib/actions/auth.ts` — must exist
    - Grep for `dashboard` in `src/lib/supabase/middleware.ts` — must have dashboard protection logic
    - Grep for `signup` in `src/lib/supabase/middleware.ts` isTenantRoute — `/signup` must be excluded from tenant routes
    - Grep for `getUser` in `src/app/dashboard/owner/layout.tsx` — defense-in-depth role check
  </verify>
  <done>
    Owner can sign up with restaurant name, email, password — gets redirected to login with success message. Owner can log in and land on /dashboard/owner. Manager can log in and land on /dashboard/manager. Unauthenticated users are redirected to /login. Role mismatch redirects to /login. Service role client factory exists for admin operations.
  </done>
</task>

</tasks>

<verification>
With Supabase running locally (`supabase start`):
1. Visit /signup, fill in restaurant name + email + password, submit — should redirect to /login?signup=success
2. Log in with same credentials — should land on /dashboard/owner
3. Visit /dashboard/manager while logged in as owner — should redirect to /login
4. Visit /dashboard while unauthenticated — should redirect to /login
5. `npx supabase db reset` succeeds and all new columns exist
6. `npx tsc --noEmit` passes
</verification>

<success_criteria>
- Owner signup creates auth user + restaurant + restaurant_staff atomically with cleanup on failure
- Login reads JWT claims and redirects to role-appropriate dashboard
- Middleware protects /dashboard/** routes based on auth + role
- Dashboard layouts enforce role independently of middleware (defense in depth)
- Schema migration adds all branding/config columns
- Storage bucket exists with correct RLS
</success_criteria>

<output>
After completion, create `.planning/phases/02-owner-setup/02-01-SUMMARY.md`
</output>
